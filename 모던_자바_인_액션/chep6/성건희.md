# Chapter 6. 스트림으로 데이터 수집

collect 도 다양한 요소 누적 방식을 인수로 받아 스트림을 최종 결과로 도출하는 리듀싱 연산을 수행할 수 있다.



## 컬렉터

함수형 프로그래밍은 명령형 프로그래밍에 비해 다음과 같은 장점이 있다.

1. 함수형 프로그래밍에서는 '무엇'을 원하는지 직접 명시가 가능하다. 어떤 방법으로 얻는지는 신경 쓸 필요 x
2. 다수준으로 그룹화를 수행할 때 명령형 프로그래밍은 다중 루프와 조건문을 추가하며 가독성과 유지보수성이 떨어지지만,
   함수형 프로그래밍은 필요한 컬렉터를 쉽게 추가할 수 있다.
3. 리듀싱 연산을 통한 높은 수준의 조합성과 재사용성



**Collectors 에서 제공하는 메서드 기능**

* 스트림 요소를 하나의 값으로 리듀스하고 요약
* 요소 그룹화
* 요소 분할



## 리듀싱과 요약

컬렉터로 스트림의 모든 항목을 하나의 결과로 합칠 수 있다.



**Collectors.maxBy** : 스트림 값에서 최댓값
**Collectors.minBy** : 스트림 값에서 최솟값



### 요약 연산

스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산

* Collectors.summingInt
* summarizingInt : 두 개 이상의 연산을 한번에 수행
* 등등 ...



### 문자열 연결

**joining** : 스트림의 각 객체에 toString 메서드를 호출해서 추출한 모든 문자열을 하나의 문자열로 연결해서 반환 (내부적으로 StringBuilder 이용)



### 범용 리듀싱 요약 연산

모든 컬랙터는 reducing 팩토리 메서드(Collectors.reducing)로 정의할 수 있지만, 특화된 컬렉터를 사용하는 이유는 **프로그래밍적 편의성** 때문이다.



### collect VS reduce

* collect : 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드. 가변 켠테이너 관련 작업이며 병렬성을 확보할때 사용
* reduce : 두 값을 하나로 도출하는 불변형 연산



## 그룹화

명령형으로 그룹화를 하면 까다롭고, 할일이 많으며, 에러도 발생함.

자바 8의 함수형을 이용하면 **가독성 있는 한 줄의 코드로 그룹화**를 구현할 수 있다.



### 분류 함수

함수를 기준으로 그룸화

* Collectors.groupingBy

단순한 속성 접근자 대신 더 복잡한 분류 기준이 필요한 상황에서는 메서드 참조를 분류 함수로 사용할 수 없다.

따라서, 이때는 메서드 참조 대신 **람다 표현식**으로 구현해야함.



### 다수준 그룹화

Collectors.groupingBy를 이용하여 항목을 다수준으로 그룹화 할 수 있다.



리듀싱 컬렉터는 절대 Optional.empty()를 반환하지 않으므로 안전한 코드다.



## 분할

분할은 **분할 함수** 라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다.

불리언을 반환하므로 맵의 키 형식은 Boolean



### 분할의 장점

* 분할 함수가 반환하는 참, 거짓 두 가지 요소의 스트림 리스트를 모두 유지한다
* 반환한 맵 구현은 참과 거짓 두 가지 키만 포함하므로 더 간결하고 효과적



## Collector 인터페이스

Collector 인터페이스는 리듀싱 연산을 어떻게 구현할지 제공하는 메서드 집합



```java
public interface Collector<T, A, R> {
  Supplier<A> supplier();
  BiConsumer<A, T> accumulator();
  Function<A, R> finisher();
  BinaryOperator<A> combiner();
  Set<Characteristics> characteristics();
}
```

T : 수집될 스트림 항목의 제네릭 형식
A : 누적자
R : 수집 연산 결과 객체의 형식



### supplier 메서드

> 새로운 결과 컨테이너 만들기

빈 결과로 이루어진 Supplier를 반환



### accumulator 메서드

>  결과 컨테이너에 요소 추가하기

리듀싱 연산을 수행하는 함수를 반환



### finisher 메서드

> 최종 변환값을 결과 컨테이너로 적용하기

스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환



### combiner 메서드

> 두 결과 컨테이너 병합

스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의



### characteristics 메서드

컬렉터의 연산을 정의하는 characteristics 형식의 불변 집합을 반환

스트림을 병렬로 리듀스할 것인지, 병렬로 리듀스한다면 어떤 최적화를 선택해야 할지 힌트 제공

characteristics 는 3 항목 (UNORDERED, CONCURRENT, IDENTITY_FINISH) 을 포함하는 열겨형임



### 컬렉터 구현을 만들지 않고 커스텀 수집 수행하기

IDENTITY_FINISH 수집 연산에서는 Collector 인터페이스를 완전히 새로 구현하지 않고도 같은 결과를 얻을 수 있다.



## 커스텀 컬렉터를 구현하여 성능 개선하기

컬렉터는 컬렉터 수집 과정에서 부분결과에 접근할 수 없다.

이때 커스텀 컬렉터를 통해 성능을 개선할 수 있다.



### 커스텀 컬렉터 구현법

1. Collector 클래스 시그니처 정의
2. 리듀싱 연산 구현
3. 병렬 실행할 수 있는 컬렉터 만들기 (가능하다면)
4. finisher 메서드와 컬렉터의 characteristices 메서드를 구현



### 컬렉터 성능 비교

팩토리 메서드로 만든 코드와 커스텀 컬렉터로 만든 코드의 기능은 같다.

하지만 성능차이는? 커스텀 컬렉터 예제소스의 성능 향상은 약 32퍼센트



컬렉터 구현을 만들지 않으면 결과코드는 간결하지만 가독성은 떨어진다.

따라서 적절한 클래스로 커스텀 컬렉터를 구현하는 것이 중복을 피하고 재사용성을 높이는데 도움이 된다.
